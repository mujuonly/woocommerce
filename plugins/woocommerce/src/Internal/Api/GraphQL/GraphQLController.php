<?php

namespace Automattic\WooCommerce\Internal\Api\GraphQL;

use GraphQL\Error\Error;
use GraphQL\Error\FormattedError;
use GraphQL\GraphQL;
use GraphQL\Type\Schema;
use GraphQL\Error\ClientAware;
use GraphQL\Error\DebugFlag as Debug;
use \GraphQL\Type\Definition\ResolveInfo;

use Automattic\WooCommerce\Internal\Api\Autogenerated\RootQueryType; //!!!AutogeneratedMock
use Automattic\WooCommerce\Internal\Api\Autogenerated\RootMutationType; //!!!AutogeneratedMock

class GraphQLController {

	private static $container;
	private static $types_cache = [];

    private static $primitive_type_names = ['int', 'string', 'boolean', 'float'];

	private static $type_namespaces = array( 'Enums', 'InputTypes', 'ObjectTypes' );

	public static function initialize(): void {
		self::$container = wc_get_container();

        \GraphQL\Error\FormattedError::setInternalErrorMessage("Unexpected error");

		add_action(
			'rest_api_init',
			function () {
				register_rest_route(
					'wc/v4',
					'/graphql',
					array(
						'methods'             => 'POST',
						'callback'            => fn( $request ) => self::handle_request($request),
						'permission_callback' => '__return_true',
					)
				);
			}
		);
	}

	private static function handle_request( \WP_REST_Request $request ) {
		try {
			$input = json_decode( $request->get_body(), true );
			if ( is_null( $input ) ) {
				// Should never happen since WP REST engine already catches invalid JSON errors, but it doesn't hurt to check it anyway.
				return self::error_response( 'Invalid input JSON: ' . json_last_error_msg(), 'rest_invalid_json', 400 );
			}
			if ( ! isset( $input['query'] ) ) {
				return self::error_response( "Invalid input JSON: no 'query' element", 'rest_invalid_json', 400 );
			}

			$query           = $input['query'];
			$variable_values = isset( $input['variables'] ) ? $input['variables'] : null;

			$schema = new Schema(
				array(
					'query'      => new RootQueryType(),
					'mutation'   => new RootMutationType(),
					'typeLoader' => function( $name ) {
						return self::resolve_type( $name );
					},
				)
			);

            //TODO: Client aware exceptions without depending on the webonix/graphql infrastructure (maybe using https://webonyx.github.io/graphql-php/error-handling/#custom-error-handling-and-formatting).
			$result = GraphQL::executeQuery( $schema, $query, null, null, $variable_values )
                ->setErrorFormatter(fn (Error $error): array => self::format_error($error));
			return $result->toArray( self::get_debug_config() );
		} catch ( \Exception $e ) {
			return self::error_response( $e, 'internal_server_error', 500 );
		}
	}

	private static function error_response( $error, $code, $status_code ) {
		if ( is_string( $error ) ) {
			return new \WP_Error( $code, $error, array( 'status' => $status_code ) );
		} elseif ( self::get_debug_config() ) {
			return new \WP_Error(
				$code,
				$error->getMessage(),
				array(
					'status' => $status_code,
					'trace'  => $error->getTrace(),
				)
			);
		} else {
			return new \WP_Error( $code, 'Internal server error', array( 'status' => $status_code ) );
		}
	}

	/**
	 * Get debug flags for GraphQL::executeQuery()->toArray.
	 *
	 * When debug flags are returned error output will always include the exception error message
	 * (even for exceptions that are not ApiException) and the output will also include
	 * a full stack trace.
	 *
	 * Debug flags are returned when "?verbose_errors" is added to the query string AND
	 * either the user is in the "administrator" role OR the WP_DEBUG constant is set.
	 *
	 * @return false|int Debug flags or false.
	 */
	private static function get_debug_config() {
		// phpcs:ignore WordPress.Security.NonceVerification.Recommended
		if ( ! isset( $_GET['verbose_errors'] ) ) {
			return false;
		}

		if ( wc_current_user_has_role( 'administrator' ) || ( defined( 'WP_DEBUG' ) && WP_DEBUG ) ) {
			return Debug::INCLUDE_DEBUG_MESSAGE | Debug::INCLUDE_TRACE;
		}

		return false;
	}

	public static function resolve_type( $name ): object {
        if(str_contains($name, "\\")) {
            $name = substr( strrchr( $name, '\\' ), 1 );
        }

        if(in_array($name, self::$primitive_type_names)) {
            return \GraphQL\Type\Definition\Type::$name();
        }

		$type_class_name = 'Automattic\\WooCommerce\\Internal\\Api\\Autogenerated\\GraphQLTypes\\' . $name . 'Type'; //!!!AutogeneratedMock
		$instance = self::$types_cache[$type_class_name] ?? null;
		if(!is_null($instance)) {
			return $instance;
		}

        $api_class_name = 'Automattic\\WooCommerce\\Api\\' . $name;
        $container = wc_get_container();
        if($container->has($api_class_name)) {
            return $container->get($api_class_name);
        }

		if(class_exists($type_class_name)) {
			$instance = new $type_class_name();
			self::$types_cache[$type_class_name] = $instance;
			return $instance;
		}

		throw new \Exception( "There's no way to resolve the type '" . $name . "'." );
	}

    public static function get_fields_info(ResolveInfo $info) {
        return self::get_fields_info_core($info->lookAhead()->queryPlan());
    }

    private static function get_fields_info_core(array $fields) {
        $result = [];

        foreach($fields as $key => $value) {
            if(empty($value['fields']) && empty($value['args'])) {
                $result[$key] = true;
                continue;
            }

            if(!empty($value['args'])) {
                $result[$key]['_args'] = $value['args'];
            }

            if(!empty($value['fields'])) {
                $result[$key] = array_merge($result[$key] ?? [], self::get_fields_info_core($value['fields']));
            }
        }

        return $result;
    }

    public static function parse_input_value(string $type_name, array $input_values) {
        $class_name = 'Automattic\\WooCommerce\\Api\\InputTypes\\' . $type_name;
        $instance = new $class_name();
        $properties = get_class_vars($class_name);
        foreach(array_keys($properties) as $property) {
            $instance->{$property} = $input_values[$property] ?? null;
        }
        return $instance;
    }

    private static function format_error(Error $error) {
        $result = FormattedError::createFromException($error);
        $actual_exception = $error->getPrevious();
        if(!$actual_exception) {
            return $result;
        }

        if(($actual_exception instanceof \InvalidArgumentException ) || (method_exists($actual_exception, 'is_client_aware') && $actual_exception->is_client_aware())) {
            $result['message'] = $actual_exception->getMessage();
        }

        return $result;
    }
}
