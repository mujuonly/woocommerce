<?php

namespace Automattic\WooCommerce\Internal\Api\DesignTime\Scripts;

use \ReflectionClass;
use \Attribute;
use function Complex\add;

class ApiBuilder {
    private static array $source_files = [];
    private static string $base_source_dir =  __DIR__ . '/../../../../Api';
    private static string $base_internal_dir = __DIR__ . '/../../../../Internal/Api';

    private static string $base_source_namespace = 'Automattic\\WooCommerce\\Api\\';
    private static string $base_internal_namespace = 'Automattic\\WooCommerce\\Internal\\Api\\';

	private static string $base_autogenerated_namespace = 'Automattic\\WooCommerce\\Internal\\Api\\Autogenerated\\';

    private static string $autogenerated_dir;
    private static string $templates_dir;

    private static array $reflection_classes_cache = [];

	private static array $warnings;
	private static array $errors;

	private static array $allowed_primitive_types = ['int', 'string', 'float', 'bool', 'boolean', 'array'];

	private static array $primitive_type_to_rest_type = [
		'int' => 'integer',
		'string' => 'string',
		'float' => 'number',
		'bool' => 'boolean',
		'boolean' => 'boolean',
		'array' => 'array'
	];

    public static function run(): void {
        if ( version_compare( phpversion(), '8', '<' )) {
            echo "*** This script requires PHP 8.0 or newer.\n";
            exit(1);
        }

        spl_autoload_register(fn($class_name) => self::load_class($class_name), true, true);

		self::$warnings = [];
		self::$errors = [];

        self::initialize_class_properties();
        self::initialize_use_statements_injector();
        self::find_source_files();
        self::init_autogenerated_dir();
        self::generate_api_classes_service_provider_file();
		self::generate_graphql_types();
		self::generate_graphql_query_classes(false);
		self::generate_graphql_query_classes(true);
		//self::generate_rest_controller_classes();

		if(empty(self::$errors)) {
			$date = gmdate("Y-m-d H:i:s");
			file_put_contents(self::$autogenerated_dir . '/api_generation_date.txt', $date);
		}

		$error_code = self::show_result();
		exit($error_code);
    }

	private static function show_result(): int {
		if(!empty(self::$errors)) {
			echo "Process failed, errors found:\n\n";
			foreach(self::$errors as $error) {
				echo $error;
				echo "\n\n";
			}
			return 1;
		}

		if(!empty(self::$warnings)) {
			echo "Process finished with warnings:\n\n";
			foreach(self::$warnings as $warning) {
				echo $warning;
				echo "\n\n";
			}
		} else {
			echo "Success!\n";
		}

		return 0;
	}

    private static function initialize_class_properties() {
        self::$base_source_dir = realpath(self::$base_source_dir);
        self::$base_internal_dir = realpath(self::$base_internal_dir);
        self::$autogenerated_dir = self::$base_internal_dir . '/Autogenerated';
        self::$templates_dir = self::$base_internal_dir . '/DesignTime/Templates';
    }

    private static function initialize_use_statements_injector() {
        $attribute_class_files = glob(self::$base_internal_dir . '/DesignTime/Attributes/*');
        $attribute_class_names = array_map(fn($file_name) => self::class_name_from_file_name($file_name), $attribute_class_files);
        UseStatementsInjector::register_classes_to_inject_with_use($attribute_class_names);
        stream_wrapper_unregister(UseStatementsInjector::PROTOCOL);
        stream_wrapper_register(UseStatementsInjector::PROTOCOL, UseStatementsInjector::class);
    }

    private static function find_source_files(): void {
        $source_dirs = glob(self::$base_source_dir . '/*', GLOB_ONLYDIR);
        foreach($source_dirs as $dir) {
            self::$source_files[basename($dir)] = self::file_search($dir);
        }
        self::$source_files['Apis'] = self::file_search(self::$base_source_dir, false);
    }

    private static function init_autogenerated_dir(): void {
        if(is_dir(self::$autogenerated_dir)) {
            self::recursive_rmdir(self::$autogenerated_dir, false);
        } else {
            mkdir(self::$autogenerated_dir);
        }
    }

    private static function generate_api_classes_service_provider_file() {
        $api_classes = array_map(fn($file_name) => self::class_name_from_file_name($file_name) . '::class', self::$source_files['Apis']);
        self::generate_file('ApiClassesServiceProvider', ['CLASS_NAMES' => implode(",\n\t\t", $api_classes)]);
    }

	private static function generate_graphql_types() {
		mkdir(self::$autogenerated_dir . '/GraphQLTypes');

		foreach(self::$source_files['Enums'] as $file) {
			self::generate_graphql_enum_type(self::class_name_from_file_name($file));
		}

		foreach(self::$source_files['Interfaces'] as $file) {
			self::generate_graphql_interface_type(self::class_name_from_file_name($file));
		}

		foreach(self::$source_files['InputTypes'] as $file) {
			self::generate_graphql_input_type(self::class_name_from_file_name($file));
		}

		foreach(self::$source_files['ObjectTypes'] as $file) {
			self::generate_graphql_object_type(self::class_name_from_file_name($file));
		}
	}

	private static function generate_graphql_enum_type($class_name) {
		$reflection_class = self::get_reflection_object($class_name);
		$description_attribute = self::get_attribute($reflection_class, 'Description');
		$simple_class_name = self::class_name_without_namespace($class_name);
		$description = is_null($description_attribute) ? $simple_class_name . ' enum type' : $description_attribute->description;

		$code_parts=[];
		$constants = $reflection_class->getConstants();
		foreach($constants as $constant_name => $constant_value) {
			$reflection_constant = new \ReflectionClassConstant($class_name, $constant_name);
			if(!$reflection_constant->isPublic()) {
				self::$warnings[] = "Enum type '$simple_class_name': constant '$constant_name' is not public and will be ignored.";
				continue;
			}
			$code_value = is_string($constant_value) ? self::code_string($constant_value) : $constant_value;
			$code_part = "\t\t\t\t" . self::code_string($constant_name) . " => [\n\t\t\t\t\t'value' => " . $code_value . ",\n";
			$constant_description = self::get_attribute($reflection_constant, 'Description');
			if(!is_null($constant_description)) {
				$code_part .= "\t\t\t\t\t'description' => " . self::translated_code_string($constant_description->description) . "\n";
			}
			$code_part .= "\t\t\t\t]";
			$code_parts[] = $code_part;
		}

		self::generate_file('EnumType', [
				'TYPE_NAME' => $simple_class_name,
				'QUOTED_TYPE_NAME' => self::code_string( $simple_class_name ),
				'TYPE_DESCRIPTION' => self::translated_code_string($description),
				'VALUES' => implode(",\n", $code_parts)
			],
			'GraphQLTypes/' . $simple_class_name . 'Type'
		);
	}

	private static function generate_graphql_interface_type($class_name) {
		$reflection_class = self::get_reflection_object($class_name);
		$description_attribute = self::get_attribute($reflection_class, 'Description');
		$simple_class_name = self::class_name_without_namespace($class_name);
		$description = is_null($description_attribute) ? $simple_class_name . ' interface type' : $description_attribute->description;

		$code_parts=[];
		$properties = $reflection_class->getProperties();
		foreach($properties as $property) {
			$code_part = self::generate_code_for_property_type($property, $simple_class_name, 'Interface', ['Interfaces']);
			if(!is_null($code_part)) {
				$code_parts[] = $code_part;
			}
		}

		self::generate_file('InterfaceType', [
				'TYPE_NAME' => $simple_class_name,
				'QUOTED_TYPE_NAME' => self::code_string( $simple_class_name ),
				'TYPE_DESCRIPTION' => self::translated_code_string($description),
				'FIELDS' => implode(",\n", $code_parts)
			],
			'GraphQLTypes/' . $simple_class_name . 'Type'
		);
	}

	private static function generate_graphql_input_type($class_name) {
		$reflection_class = self::get_reflection_object($class_name);
		$description_attribute = self::get_attribute($reflection_class, 'Description');
		$simple_class_name = self::class_name_without_namespace($class_name);
		$description = is_null($description_attribute) ? $simple_class_name . ' input type' : $description_attribute->description;

		$traits = $reflection_class->getTraits();
		$trait_property_names = self::get_properties_from_traits($traits);

		$code_parts=[];
		$properties = $reflection_class->getProperties();
		foreach($properties as $property) {
			if(in_array($property->getName(), $trait_property_names)) {
				continue;
			}
			$code_part = self::generate_code_for_property_type($property, $simple_class_name, 'Input', ['Interfaces', 'InputTypes']);
			if(!is_null($code_part)) {
				$code_parts[] = $code_part;
			}
		}

		$extra_fields_code = [];
		foreach($traits as $trait) {
			$trait_name = $trait->getName();
			if(!str_starts_with($trait_name, self::$base_source_namespace . 'Interfaces\\')) {
				self::$errors[] = "Input type '$simple_class_name' implements trait '$trait_name', which is not in the 'Interfaces' namespace.";
				return;
			}

			$trait_simple_name = self::class_name_without_namespace($trait_name);
			$extra_fields_code[] = "\t\t\$fields = array_merge(\$fields, GraphQLController::resolve_type('$trait_simple_name')->get_fields());";
		}

		try {
			$parse_method = $reflection_class->getMethod('parse');
		}
		catch(\Exception $e) {
			// Method doesn't exist
			$parse_method = null;
		}

		$parse_code = null;
		if(!is_null($parse_method) && $parse_method->isStatic() && $parse_method->isPublic()) {
			$parse_args = $parse_method->getParameters();
			if(count($parse_args) === 1) {
				$parse_arg_type = current($parse_args)->getType();
				if(!is_null($parse_arg_type) && $parse_arg_type->getName() === 'array') {
					$parse_code = $class_name . '::parse( $values )';
				}
			}
		}

		if(is_null($parse_code)) {
			if(!is_null($parse_method)) {
				self::$warnings[] = "Input type '$simple_class_name' has a 'parse' method, but it either isn't static, isn't public or doesn't accept one single argument of type 'array'; thus it won't be used for parsing input arrays.";
			}
			$parse_code = "GraphQLController::parse_input_value( '$simple_class_name', \$values )";
		}

		self::generate_file('InputType', [
			'TYPE_NAME' => $simple_class_name,
			'QUOTED_TYPE_NAME' => self::code_string( $simple_class_name ),
			'PARSE_CODE' => $parse_code,
			'TYPE_DESCRIPTION' => self::translated_code_string($description),
			'FIELDS' => implode(",\n", $code_parts),
			'EXTRA_FIELDS' => implode("\n", $extra_fields_code),
		],
			'GraphQLTypes/' . $simple_class_name . 'Type'
		);
	}

	private static function generate_graphql_object_type($class_name) {
		$reflection_class = self::get_reflection_object($class_name);
		$description_attribute = self::get_attribute($reflection_class, 'Description');
		$simple_class_name = self::class_name_without_namespace($class_name);
		$description = is_null($description_attribute) ? $simple_class_name . ' object type' : $description_attribute->description;

		$traits = $reflection_class->getTraits();
		$trait_property_names = self::get_properties_from_traits($traits);

		$code_parts=[];
		$properties = $reflection_class->getProperties();
		foreach($properties as $property) {
			if(in_array($property->getName(), $trait_property_names)) {
				continue;
			}
			$code_part = self::generate_code_for_property_type($property, $simple_class_name, 'Object', ['Interfaces', 'ObjectTypes']);
			if(!is_null($code_part)) {
				$code_parts[] = $code_part;
			}
		}

		$interfaces_code = [];
		$extra_fields_code = [];

		foreach($traits as $trait) {
			$trait_name = $trait->getName();
			if(!str_starts_with($trait_name, self::$base_source_namespace . 'Interfaces\\')) {
				self::$errors[] = "Object type '$simple_class_name' implements trait '$trait_name', which is not in the 'Interfaces' namespace.";
				return;
			}

			$trait_simple_name = self::class_name_without_namespace($trait_name);
			$interfaces_code[] = "\t\t\t\tGraphQLController::resolve_type('$trait_simple_name')";
			$extra_fields_code[] = "\t\t\$fields = array_merge(\$fields, GraphQLController::resolve_type('$trait_simple_name')->get_fields());";
		}

		self::generate_file('ObjectType', [
			'TYPE_NAME' => $simple_class_name,
			'QUOTED_TYPE_NAME' => self::code_string( $simple_class_name ),
			'INTERFACES' => implode(",\n", $interfaces_code),
			'TYPE_DESCRIPTION' => self::translated_code_string($description),
			'FIELDS' => implode(",\n", $code_parts),
			'EXTRA_FIELDS' => implode("\n", $extra_fields_code),
		],
			'GraphQLTypes/' . $simple_class_name . 'Type'
		);
	}

	private static function get_properties_from_traits(array $traits) {
		$trait_property_names = [];

		foreach($traits as $trait) {
			foreach($trait->getProperties() as $property) {
				$trait_property_names[] = $property->getName();
			}
		}

		return $trait_property_names;
	}

	private static function generate_code_for_property_type(\ReflectionProperty $property, string $simple_class_name, string $type_kind, array $allowed_type_namespaces) : ?string {
		$property_name = $property->getName();
		if(!$property->isPublic()) {
			self::$warnings[] = "$type_kind type '$simple_class_name': property '$property_name' is not public and will be ignored.";
			return null;
		}

		$property_type = $property->getType();
		$enum_type_attribute = self::get_attribute($property, 'EnumType');
		$array_of_attribute = self::get_attribute($property, 'ArrayType');

		$type_code = self::generate_code_for_type($property_type, $enum_type_attribute, $array_of_attribute, "$type_kind type '$simple_class_name': property '$property_name'", $allowed_type_namespaces);

		$code_part = "\t\t\t" . self::code_string($property_name) . " => fn() => [\n\t\t\t\t'type' => " . $type_code . ",\n";
		$property_description = self::get_attribute($property, 'Description');
		if(!is_null($property_description)) {
			$code_part .= "\t\t\t\t'description' => " . self::translated_code_string($property_description->description) . "\n";
		}
		$code_part .= "\t\t\t]";

		return $code_part;
	}

	private static function generate_code_for_type(\ReflectionNamedType $type, $enum_type_attribute, $array_of_attribute, string $error_message_prefix, array $allowed_type_namespaces): ?string {
		$type_name = $type->getName();
		$is_array = false;
		$is_enum = false;

		if(!is_null($enum_type_attribute)) {
			$is_enum = true;
			$enum_property_type_name = $enum_type_attribute->class_name;
			if(!str_starts_with($enum_property_type_name, self::$base_source_namespace . 'Enums\\')) {
				self::$errors[] = "$error_message_prefix has an 'EnumType' attribute declaring the type '$enum_property_type_name', which is not in the 'Enums' namespace.";
				return null;
			}
		}

		if(!in_array($type_name, self::$allowed_primitive_types)) {
			if(!$is_enum && str_starts_with($type_name, self::$base_source_namespace . 'Enums\\')) {
				self::$errors[] = "$error_message_prefix is of type '$type_name'. Set the property type to the underlying primitive type an use the 'EnumType' attribute instead.";
			}

			if(!$is_enum) {
				$valid_type = false;
				foreach($allowed_type_namespaces as $allowed_type_namespace) {
					if(str_starts_with($type_name, self::$base_source_namespace . $allowed_type_namespace . '\\')) {
						$valid_type = true;
						break;
					}
				}

				if(!$valid_type) {
					$valid_types_string = "'" . implode("', '", $allowed_type_namespaces) . "'";
					self::$errors[] = "$error_message_prefix is of type '$type_name'. Only primitive types (int, float, string, bool, array) and types in the $valid_types_string namespaces are allowed.";
					return null;
				}
			}

			$is_primitive = false;
		}
		else {
			$is_primitive = true;
			$is_array = $type_name === 'array';
			if($is_array) {
				if (is_null($array_of_attribute)) {
					self::$errors[] = "$error_message_prefix is of type 'array', but it lacks the 'ArrayType' attribute.";
					return null;
				}
				$array_type_name = $array_of_attribute->class_name;
				$array_type_is_nullable = $array_of_attribute->nullable;

				if(!in_array($array_type_name, self::$allowed_primitive_types)) {
					$is_primitive = false;

					if(!$is_enum && str_starts_with($array_type_name, self::$base_source_namespace . 'Enums\\')) {
						self::$errors[] = "$error_message_prefix is of type array of '$array_type_name'. Set the property type to the underlying primitive type an use the 'EnumType' attribute instead.";
						return null;
					}

					if(!$is_enum) {
						$valid_type = false;
						foreach($allowed_type_namespaces as $allowed_type_namespace) {
							if(str_starts_with($array_type_name, self::$base_source_namespace . $allowed_type_namespace . '\\')) {
								$valid_type = true;
								break;
							}
						}

						if(!$valid_type) {
							$valid_types_string = "'" . implode("', '", $allowed_type_namespaces) . "'";
							self::$errors[] = "$error_message_prefix is of type array of '$array_type_name'. Only primitive types (int, float, string, bool, array) and types in the $valid_types_string namespaces are allowed.";
							return null;
						}
					}
				}

				$type_name = $array_type_name;
			}
		}

		if($is_enum) {
			if(!$is_primitive) {
				self::$errors[] = "$error_message_prefix has an 'EnumType' attribute but is of type '$type_name'. Only primitive types (int, float, string, bool, array of those) are allowed as the underlying type when 'EnumType' is present.";
				return null;
			}
			$type_name = $enum_property_type_name;
			$is_primitive = false;
		}
		else if($is_primitive) {
			$type_name = preg_replace('/^bool$/', 'boolean', $type_name);
			$type_name = "Type::$type_name()";
		}

		if(!$is_primitive) {
			if(!class_exists($type_name) && !(str_starts_with($type_name, self::$base_source_namespace . 'Interfaces\\') && trait_exists($type_name))) {
				self::$errors[] = "$error_message_prefix is declared as being of type '$type_name', which doesn't exist.";
				return null;
			}

			$type_name = "GraphQLController::resolve_type( '" . self::class_name_without_namespace($type_name) . "' )";
		}

		$is_nullable = $type->allowsNull();

		if($is_array) {
			if($is_nullable) {
				if($array_type_is_nullable) {
					$type_code = "Type::listOf($type_name)";
				}
				else {
					$type_code = "Type::listOf(Type::nonNull($type_name))";
				}
			}
			else {
				if($array_type_is_nullable) {
					$type_code = "Type::nonNull(Type::listOf($type_name))";
				}
				else {
					$type_code = "Type::nonNull(Type::listOf(Type::NonNull($type_name)))";
				}
			}
		}
		else {
			if($is_nullable) {
				$type_code = $type_name;
			}
			else {
				$type_code = "Type::nonNull($type_name)";
			}
		}

		return $type_code;
	}

	private static function generate_rest_controller_classes() {
		mkdir(self::$autogenerated_dir . '/RestControllers');

		$class_files = self::$source_files['Apis'];
		$used_class_names = [];
		foreach($class_files as $class_file) {
			$class_name = self::class_name_from_file_name($class_file);
			$simple_class_name = self::class_name_without_namespace($class_name);
			$reflection_class = self::get_reflection_object($class_name);
			$methods = $reflection_class->getMethods(\ReflectionMethod::IS_PUBLIC);
			$method_entries = [];
			$run_method_entries = [];
			foreach($methods as $method) {
				$is_mutation = false;
				$query_attribute = self::get_attribute($method, 'WebQuery');
				if(is_null($query_attribute)) {
					$query_attribute = self::get_attribute($method, 'WebMutation');
					if(is_null($query_attribute)) {
						continue;
					}
					$is_mutation = true;
				}

				$query_name = $query_attribute->rest_name ?? strtolower(preg_replace('/(?<!^)[A-Z]/', '_$0', $query_attribute->graphql_name));
				$description_attribute = self::get_attribute($method, 'Description');
				$description = is_null($description_attribute) ? $query_name . $is_mutation ? ' mutation' : ' query' . ' REST endpoint' : $description_attribute->description;

				//TODO: Schema.

				$method_name = $method->getName();

				$arguments = $method->getParameters();
				$arguments_code = [];
				$arguments_use_code = [];
				$arguments_description_attributes = self::get_argument_attributes($method, 'ArgDescription');
				$arguments_array_of_attributes = self::get_argument_attributes($method, 'ArgArrayType');
				$arguments_enum_type_attributes = self::get_argument_attributes($method, 'ArgEnumType');
				foreach($arguments as $argument) {
					$arg_name = $argument->getName();
					$arg_type = $argument->getType();

					$array_of_attribute = self::get_attribute($argument, 'ArrayType') ?? $arguments_array_of_attributes[$arg_name] ?? null;
					$enum_type_attribute = self::get_attribute($argument, 'EnumType') ?? $arguments_enum_type_attributes[$arg_name] ?? null;
					$arg_type_code = self::generate_code_for_type($arg_type, $enum_type_attribute, $array_of_attribute, "Api class '$simple_class_name': method '$method_name': argument '$arg_name'", ['InputTypes']);
					if(is_null($arg_type_code)) {
						continue;
					}

					$arg_type_name = $arg_type->getName();
					$is_nullable = $argument->allowsNull();
					$is_array = 'array' === $arg_type_name;
					$is_object = !$is_array && !isset(self::$primitive_type_to_rest_type[$arg_type_name]);
					$arg_type_code = $is_object ? 'object' : self::$primitive_type_to_rest_type[ $arg_type_name ];

					$description_attribute = self::get_attribute($argument, 'Description') ?? $arguments_description_attributes[$arg_name] ?? null;
					$arg_description = is_null($description_attribute) ? '' : "\t\t\t\t'description' => " . self::translated_code_string($description_attribute->description) . ",\n\t\t\t\t\t";
					$arguments_code[] =
						"\n\t\t\t\t\t\t" . self::code_string($argument->getName()) . " => [\n\t\t\t$arg_description\t\t'type' => '$arg_type_code',\n" .
						"\t\t\t\t\t\t\t'context' => array('view', 'edit'),\n" .
						"\t\t\t\t\t\t\t'readonly' => true,\n" .
						"\t\t\t\t\t\t\t'required' => " . ($is_nullable ? 'false' : 'true') . ",\n" .
						($is_array ? "\t\t\t\t\t\t\t\t'items' => ['type' => ' " . $array_of_attribute->class_name . "']\n" : '') .
						($is_object ? "\t\t\t\t\t\t\t\t// TODO: Object properties.\n" : '').
						"\t\t\t\t\t\t\t]";
					//TODO: object properties.

					if($is_array && !isset(self::$primitive_type_to_rest_type[$array_of_attribute->class_name])) {
						$input_type_class_name = self::class_name_without_namespace($array_of_attribute->class_name);
						$arguments_use_code[] = "array_map(fn(\$item) => GraphQLController::resolve_type('${input_type_class_name}')->parseValue( \$item ), \$request['$arg_name'] )";
					}
					else if($is_object) {
						$input_type_class_name = self::class_name_without_namespace($arg_type_name);
						$arguments_use_code[] = "GraphQLController::resolve_type('${input_type_class_name}')->parseValue( \$request['$arg_name'] )";
					}
					else {
						$arguments_use_code[] = "\$request['$arg_name']";
					}
				}

				$method_entries[] =
					"\t\tregister_rest_route(\n" .
					"\t\t\t\$this->route_namespace,\n" .
					"\t\t\t'/$query_name',\n" .
					"\t\t\tarray(\n".
					"\t\t\t\tarray(\n".
					"\t\t\t\t\t'methods' => \\WP_REST_Server::" . ($is_mutation ? 'CREATABLE' : 'READABLE') . ",\n".
					"\t\t\t\t\t'callback' => fn( \$request ) => \$this->run( \$request, 'run_" . $method_name . "' ),\n".
					"\t\t\t\t\t'permission_callback' => '__return_true',\n".
					"\t\t\t\t\t'args' => array(" .
					implode(",\t\t\t\t\t\t", $arguments_code) .
					"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);";

				$args_use_code_imploded = implode(', ', $arguments_use_code);
				$run_method_entries[] =
					"\tpublic function run_$method_name( \\WP_REST_Request \$request ) {\n" .
					"\t\treturn wc_get_container()->get( $simple_class_name::class )->$method_name($args_use_code_imploded);\n" .
					"\t}\n";
			}

			if(empty($method_entries)) {
				continue;
			}

			self::generate_file(
				'ClassRestController',
				[
					'CLASS_NAME' => $class_name,
					'SIMPLE_CLASS_NAME' => $simple_class_name,
					'ROUTE_REGISTRATIONS' => implode("\n\n", $method_entries),
					'RUN_METHODS' => implode("\n", $run_method_entries),
				],
				'RestControllers/' . $simple_class_name . 'Controller'
			);

			$used_class_names[] = "\\" . self::$base_autogenerated_namespace . "RestControllers\\" . $simple_class_name . 'Controller::class';
		}

		if(empty($used_class_names)) {
			return;
		}

		self::generate_file('RestControllersServiceProvider', ['CLASS_NAMES' => implode(",\n\t\t", $used_class_names)]);
	}

	private static function generate_graphql_query_classes(bool $generate_mutations) {
		$operation_upper_name = $generate_mutations ? 'Mutation' : 'Query';
		$operation_upper_plural_name = $generate_mutations ? 'Mutations' : 'Queries';
		$operation_lower_name = strtolower($operation_upper_name);
		$operation_lower_plural_name = strtolower($operation_upper_plural_name);

		mkdir(self::$autogenerated_dir . '/GraphQL' . $operation_upper_plural_name);

		$class_files = self::$source_files['Apis'];
		$used_class_names = [];
		foreach($class_files as $class_file) {
			$class_name = self::class_name_from_file_name($class_file);
			$simple_class_name = self::class_name_without_namespace($class_name);
			$reflection_class = self::get_reflection_object($class_name);
			$methods = $reflection_class->getMethods(\ReflectionMethod::IS_PUBLIC);
			$method_entries = [];
			foreach($methods as $method) {
				$query_attribute = self::get_attribute($method, 'Web' . $operation_upper_name);
				if(is_null($query_attribute)) {
					continue;
				}

				$query_name = $query_attribute->graphql_name;
				$description_attribute = self::get_attribute($method, 'Description');
				$description = is_null($description_attribute) ? $query_attribute->graphql_name . ' ' . $operation_lower_name . ' type' : $description_attribute->description;

				$enum_type_attribute = self::get_attribute($method, 'EnumType');
				$array_of_attribute = self::get_attribute($method, 'ArrayType');
				$method_name = $method->getName();

				$return_type_name = $method->getReturnType()->getName();
				if(('array' === $return_type_name || '?array' === $return_type_name)) {
					if(is_null($array_of_attribute)) {
						self::$errors[] = "Api type '$simple_class_name': method '$method_name': return value is of type array, but the method lacks the 'ArrayType' attribute.";
						continue;
					}
					$return_type_array_of_name = $array_of_attribute->class_name;
					if(in_array($return_type_array_of_name, self::$allowed_primitive_types, true)) {
						self::$errors[] = "Api type '$simple_class_name': method '$method_name': return value is of type array of '$return_type_array_of_name', only types in the 'ObjectTypes' namespace are allowed.";
						continue;
					}
				}
				else if(in_array($return_type_name, self::$allowed_primitive_types, true)) {
					self::$errors[] = "Api type '$simple_class_name': method '$method_name': return value is of type '$return_type_name', only types in the 'ObjectTypes' namespace are allowed.";
					continue;
				}

				$type_code = self::generate_code_for_type($method->getReturnType(), $enum_type_attribute, $array_of_attribute, "Api type '$simple_class_name': method '$method_name': return value", ['ObjectTypes', 'Interfaces']); //WIP

				$arguments = $method->getParameters();
				$arguments_code = [];
				$arguments_description_attributes = self::get_argument_attributes($method, 'ArgDescription');
				$arguments_array_of_attributes = self::get_argument_attributes($method, 'ArgArrayType');
				$arguments_enum_type_attributes = self::get_argument_attributes($method, 'ArgEnumType');
				$resolve_arguments_code = [];
				foreach($arguments as $argument) {
					$arg_name = $argument->getName();
					$arg_type = $argument->getType();

					if('_fields_info' === $arg_name) {
						if($arg_type->getName() !== 'array' || ! $arg_type->allowsNull()) {
							self::$errors[] = "Api class '$simple_class_name': method '$method_name': argument '_fields_info' must be of type '?array'";
							continue;
						}
						$resolve_arguments_code[] = "GraphQLController::get_fields_info( \$info )";
					}
					else {
						$array_of_attribute = self::get_attribute($argument, 'ArrayType') ?? $arguments_array_of_attributes[$arg_name] ?? null;
						$enum_type_attribute = self::get_attribute($argument, 'EnumType') ?? $arguments_enum_type_attributes[$arg_name] ?? null;
						$arg_type_code = self::generate_code_for_type($arg_type, $enum_type_attribute, $array_of_attribute, "Api class '$simple_class_name': method '$method_name': argument '$arg_name'", ['InputTypes']);
						if(is_null($arg_type_code)) {
							continue;
						}

						$description_attribute = self::get_attribute($argument, 'Description') ?? $arguments_description_attributes[$arg_name] ?? null;
						$arg_description = is_null($description_attribute) ? '' : "\t'description' => " . self::translated_code_string($description_attribute->description) . ",\n\t\t\t\t\t";
						$arguments_code[] = "\n\t\t\t\t\t" . self::code_string($argument->getName()) . " => [\n\t\t\t\t\t$arg_description\t'type' => $arg_type_code\n\t\t\t\t\t]";
						$resolve_arguments_code[] = $argument->allowsNull() ? "\$args['$arg_name'] ?? null" : "\$args['$arg_name']";
					}
				}

				$resolve_arguments_all_code = implode(', ', $resolve_arguments_code);
				$method_entries[] = "\t\t\t'$query_name' => [\n\t\t\t\t'type' => $type_code,\n\t\t\t\t'description' => " . self::translated_code_string($description) . ",\n\t\t\t\t'args' =>[" . implode(",\t\t\t\t\t", $arguments_code) . "\n\t\t\t\t],\n\t\t\t\t'resolve'=> fn( \$object_value, array \$args, \$context, ResolveInfo \$info) => \$container->get( $simple_class_name::class )->$method_name($resolve_arguments_all_code)\n\t\t\t]";
			}

			if(empty($method_entries)) {
				continue;
			}

			$used_class_names[] = "\t\t\tGraphQL" . $operation_upper_plural_name ."\\" . $simple_class_name . $operation_upper_plural_name . '::get_' . $operation_lower_plural_name . '()';

			self::generate_file(
				'ClassGraphQLQueries',
				[
					'CLASS_NAME' => $simple_class_name . $operation_upper_plural_name,
					'API_CLASS_SIMPLE_NAME' => $simple_class_name,
					'API_CLASS_NAME' => $class_name,
					'QUERIES' => implode(",\n", $method_entries),
					'OPERATION_LOWER_PLURAL' => $operation_lower_plural_name,
					'OPERATION_UPPER_PLURAL' => $operation_upper_plural_name
				],
				'GraphQL' . $operation_upper_plural_name . '/' . $simple_class_name . $operation_upper_plural_name
			);
		}

		if(empty($used_class_names)) {
			return;
		}

		self::generate_file(
			'RootGraphQLType',
			['CLASS_NAME' => 'Root' . $operation_upper_name . 'Type',
				'OPERATION_UPPER' => $operation_upper_name,
				'OPERATION_LOWER' => $operation_lower_name,
				'QUERIES' => implode(",\n", $used_class_names)],
			'Root' . $operation_upper_name . 'Type'
		);
	}

	private static function get_argument_attributes(\ReflectionMethod $method, string $attribute_name): array {
		$attribute_name = self::$base_internal_namespace . 'DesignTime\\Attributes\\' . $attribute_name . 'Attribute';
		$all_attributes = $method->getAttributes();
		$attributes_of_type = array_filter($all_attributes, fn($attribute) => $attribute->getName() === $attribute_name);
		$result = [];
		$warned = false;
		foreach($attributes_of_type as $attribute) {
			$attribute_instance = $attribute->newInstance();
			$arg_name = $attribute->newInstance()->arg_name;
			if(!$warned && isset($result[$arg_name])) {
				$class_name = self::class_name_without_namespace( $method->getDeclaringClass()->getName() );
				$method_name = $method->getName();
				self::$warnings[] = "Api class '$class_name': method '$method_name' has multiple instances of attribute '$attribute_name', only one will be used.";
				$warned = true;
			}
			$result[$arg_name] = $attribute_instance;
		}
		return $result;
	}

    private static function get_reflection_object(string $class_name) {
        if(!isset(self::$reflection_classes_cache[$class_name])) {
            self::$reflection_classes_cache[$class_name] = new ReflectionClass($class_name);
        }
        return self::$reflection_classes_cache[$class_name];
    }

	private static function get_attribute($item, $name) {
		$name = self::$base_internal_namespace . 'DesignTime\\Attributes\\' . $name . 'Attribute';
		$all_attributes = $item->getAttributes();
		$attributes_of_type = array_filter($all_attributes, fn($attribute) => $attribute->getName() === $name);
		return empty($attributes_of_type) ? null : current($attributes_of_type)->newInstance();

		//TODO: Why the following doesn't work??
		//$attributes = $item->getAttributes( self::$base_internal_namespace . 'DesignTime\\Attributes\\' . $name . '\\Attribute');
		//return empty($attributes) ? null : current($attributes)->newInstance();
	}

    private static function generate_file(string $template_name, array $contents, string $target_file_name = null) {
        $target_file_name ??= $template_name;
        $template_contents = file_get_contents(self::$templates_dir . '/' . $template_name . '.template');
        foreach($contents as $key => $value) {
            $template_contents = str_replace('{{' . $key . '}}', $value, $template_contents);
        }

        $template_contents = trim($template_contents) . "\n\n// Autogenerated file, don't modify manually!\n";

		stream_wrapper_unregister(UseStatementsInjector::PROTOCOL);
		stream_wrapper_restore(UseStatementsInjector::PROTOCOL);
		file_put_contents(self::$autogenerated_dir . '/' . $target_file_name . '.php', $template_contents);
		stream_wrapper_unregister(UseStatementsInjector::PROTOCOL);
		stream_wrapper_register(UseStatementsInjector::PROTOCOL, UseStatementsInjector::class);
    }

    private static function recursive_rmdir(string $dir, bool $remove_dir_itself): void {
        $objects = scandir($dir);
        foreach ($objects as $object) {
            if ($object !== "." && $object !== "..") {
                if (is_dir($dir . '/' . $object) && !is_link($dir . '/' . $object))
                    self::recursive_rmdir($dir . '/' . $object, true);
                else
                    unlink($dir . '/' .$object);
            }
        }

        if($remove_dir_itself) {
            rmdir($dir);
        }
    }

    private static function file_search(string $directory, bool $recursive = true): array {
        $directory = rtrim($directory, '/');
        $files = glob($directory.'/*.php');
        if($recursive) {
            $dirs = glob($directory . '/*', GLOB_ONLYDIR);
            foreach ($dirs as $dir) {
                if (is_dir($dir)) {
                    $files = array_merge($files, self::file_search($dir, '*.php'));
                }
            }
        }

        return array_map('realpath', $files);
    }

    private static function load_class($class_name): void {
        self::include_if_exists($class_name, self::$base_internal_namespace, self::$base_internal_dir) ||
        self::include_if_exists($class_name, self::$base_source_namespace, self::$base_source_dir);
    }

    private static function include_if_exists($class_name, $base_namespace, $base_dir_for_namespace): bool {
        if(!str_starts_with($class_name, $base_namespace)) {
            return false;
        }

        $relative_class_name = str_replace($base_namespace, '', $class_name);
        $file_path = realpath($base_dir_for_namespace) . '/' . $relative_class_name;
        $file_path = str_replace('\\', '/', $file_path) . '.php';
        if(is_file($file_path)) {
            require_once $file_path;
            return true;
        }

        return false;
    }

    private static function class_name_from_file_name(string $file_name, bool $append_colon_class = false): string {
        if(str_starts_with($file_name, self::$base_source_dir)) {
            $base_dir = self::$base_source_dir;
            $base_namespace = self::$base_source_namespace;
        }
        else {
            $base_dir = self::$base_internal_dir;
            $base_namespace = self::$base_internal_namespace;
        }

        $file_name = ltrim(str_replace($base_dir, '', $file_name), '/');
        $class_name = $base_namespace . str_replace('/', '\\', $file_name);
        return '\\' . str_replace('.php', $append_colon_class ? '::class' : '', $class_name);
    }

    private static function class_name_without_namespace( string $class_name ): string {
        // A '?:' would convert this to a one-liner, but WP coding standards disallow these :shrug:.
        $result = substr( strrchr( $class_name, '\\' ), 1 );
        return $result ? $result : $class_name;
    }

	private static function code_string(string $string) {
		return '"' . addcslashes($string, "\n\t\\'\"") . '"';
	}

	private static function translated_code_string(string $string) {
		return '__( ' . self::code_string($string) . ", 'woocommerce' )";
	}
}

ApiBuilder::run();
